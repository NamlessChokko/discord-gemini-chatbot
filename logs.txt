function _async_iterator(iterable) {
    var method, async, sync, retry = 2;
    for("undefined" != typeof Symbol && (async = Symbol.asyncIterator, sync = Symbol.iterator); retry--;){
        if (async && null != (method = iterable[async])) return method.call(iterable);
        if (sync && null != (method = iterable[sync])) return new AsyncFromSyncIterator(method.call(iterable));
        async = "@@asyncIterator", sync = "@@iterator";
    }
    throw new TypeError("Object is not async iterable");
}
function AsyncFromSyncIterator(s) {
    function AsyncFromSyncIteratorContinuation(r) {
        if (Object(r) !== r) return Promise.reject(new TypeError(r + " is not an object."));
        var done = r.done;
        return Promise.resolve(r.value).then(function(value) {
            return {
                value: value,
                done: done
            };
        });
    }
    return AsyncFromSyncIterator = function(s) {
        this.s = s, this.n = s.next;
    }, AsyncFromSyncIterator.prototype = {
        s: null,
        n: null,
        next: function() {
            return AsyncFromSyncIteratorContinuation(this.n.apply(this.s, arguments));
        },
        return: function(value) {
            var ret = this.s.return;
            return void 0 === ret ? Promise.resolve({
                value: value,
                done: !0
            }) : AsyncFromSyncIteratorContinuation(ret.apply(this.s, arguments));
        },
        throw: function(value) {
            var thr = this.s.return;
            return void 0 === thr ? Promise.reject(value) : AsyncFromSyncIteratorContinuation(thr.apply(this.s, arguments));
        }
    }, new AsyncFromSyncIterator(s);
}
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
import { SlashCommandBuilder } from 'discord.js';
import { GoogleGenAI } from '@google/genai';
export var data = new SlashCommandBuilder().setName('code').setDescription('Generate code based on your prompt').addStringOption(function(option) {
    return option.setName('prompt').setDescription('Describe what kind of code you need').setRequired(true);
});
export function execute(interaction) {
    return _async_to_generator(function() {
        var systemInstructions, prompt, gemini, responseStream, result, _iteratorAbruptCompletion, _didIteratorError, _iteratorError, _iterator, _step, _value, chunk, err, error, currentTime;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        interaction.reply({
                            content: 'Generating code...',
                            withResponse: true
                        })
                    ];
                case 1:
                    _state.sent();
                    systemInstructions = [
                        'YOUR ROLE: You are a code generator bot for Discord.',
                        'Your name is Gemini.',
                        'You use the Gemini 2.5 API.',
                        'Respond only with code unless context requires clarification.',
                        'Use comments inside code if you need to explain something.',
                        "Always respond in English, regardless of the prompt's language.",
                        "User to respond: ".concat(interaction.user.username),
                        'Do not use Markdown formatting.',
                        'Maintain a formal and neutral tone unless otherwise requested.'
                    ];
                    _state.label = 2;
                case 2:
                    _state.trys.push([
                        2,
                        19,
                        ,
                        21
                    ]);
                    prompt = interaction.options.getString('prompt');
                    if (!!prompt) return [
                        3,
                        4
                    ];
                    return [
                        4,
                        interaction.editReply('Prompt cannot be empty.')
                    ];
                case 3:
                    _state.sent();
                    return [
                        2
                    ];
                case 4:
                    gemini = new GoogleGenAI({
                        apiKey: process.env.GEMINI_API_KEY
                    });
                    return [
                        4,
                        gemini.models.generateContentStream({
                            model: 'gemini-2.5-flash',
                            contents: prompt,
                            config: {
                                temperature: 1.5,
                                maxOutputTokens: 499,
                                systemInstruction: systemInstructions
                            }
                        })
                    ];
                case 5:
                    responseStream = _state.sent();
                    result = '';
                    _iteratorAbruptCompletion = false, _didIteratorError = false;
                    _state.label = 6;
                case 6:
                    _state.trys.push([
                        6,
                        12,
                        13,
                        18
                    ]);
                    _iterator = _async_iterator(responseStream);
                    _state.label = 7;
                case 7:
                    return [
                        4,
                        _iterator.next()
                    ];
                case 8:
                    if (!(_iteratorAbruptCompletion = !(_step = _state.sent()).done)) return [
                        3,
                        11
                    ];
                    _value = _step.value;
                    chunk = _value;
                    if (!chunk.text) return [
                        3,
                        10
                    ];
                    result += chunk.text;
                    if (result.length > 1995) {
                        result = result.slice(0, 1995) + '...';
                        return [
                            3,
                            11
                        ];
                    }
                    return [
                        4,
                        interaction.editReply(result)
                    ];
                case 9:
                    _state.sent();
                    _state.label = 10;
                case 10:
                    _iteratorAbruptCompletion = false;
                    return [
                        3,
                        7
                    ];
                case 11:
                    return [
                        3,
                        18
                    ];
                case 12:
                    err = _state.sent();
                    _didIteratorError = true;
                    _iteratorError = err;
                    return [
                        3,
                        18
                    ];
                case 13:
                    _state.trys.push([
                        13,
                        ,
                        16,
                        17
                    ]);
                    if (!(_iteratorAbruptCompletion && _iterator.return != null)) return [
                        3,
                        15
                    ];
                    return [
                        4,
                        _iterator.return()
                    ];
                case 14:
                    _state.sent();
                    _state.label = 15;
                case 15:
                    return [
                        3,
                        17
                    ];
                case 16:
                    if (_didIteratorError) {
                        throw _iteratorError;
                    }
                    return [
                        7
                    ];
                case 17:
                    return [
                        7
                    ];
                case 18:
                    return [
                        3,
                        21
                    ];
                case 19:
                    error = _state.sent();
                    currentTime = new Date().toLocaleTimeString();
                    console.error("Error at ".concat(currentTime, ":"), error);
                    return [
                        4,
                        interaction.editReply('Oops! Something went wrong while generating your code.')
                    ];
                case 20:
                    _state.sent();
                    return [
                        3,
                        21
                    ];
                case 21:
                    return [
                        2
                    ];
            }
        });
    })();
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
import { SlashCommandBuilder } from 'discord.js';
var helpMessage = '\n**\uD83E\uDD16 Gemini Chat Bot Help**\n\nGemini is powered by Google\'s Gemini 2.5 Flash API, enabling natural conversations directly inside Discord.\n\n**\uD83D\uDDE8️ How to Use**\n- **Mention the bot**: Just mention "@Gemini" in any message and ask anything.\n- **Direct Messages**: You can chat with Gemini privately via DMs.\n- **Slash Commands**: Use slash commands like "/code", "/image", and more (coming soon).\n\n**\uD83D\uDCCF Limits**\n- Max response size: ~2000 characters.\n- Gemini API max tokens per response: **499 tokens**.\n\n**⚙️ Notes**\n- Answers are always in **English** regardless of the input.\n- If you joke, Gemini might joke back \uD83D\uDE09\n\nUse "@Gemini" or try a command to begin!\n';
export var data = new SlashCommandBuilder().setName('help').setDescription('Displays usage instructions and bot capabilities.');
export function execute(interaction) {
    return _async_to_generator(function() {
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        interaction.reply(helpMessage)
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    })();
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
import { SlashCommandBuilder } from 'discord.js';
import { GoogleGenAI, Modality } from '@google/genai';
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
export var data = new SlashCommandBuilder().setName('image').setDescription('Generate an image based on your prompt').addStringOption(function(opt) {
    return opt.setName('prompt').setDescription('Describe the image you want to generate').setRequired(true);
});
export function execute(interaction) {
    return _async_to_generator(function() {
        var prompt, gemini, _response_candidates__content, _response_candidates_, _response_candidates, response, parts, imageBuffer, caption, _iteratorNormalCompletion, _didIteratorError, _iteratorError, _iterator, _step, part, _part_inlineData, imgPath, error;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    prompt = interaction.options.getString('prompt');
                    if (!!prompt) return [
                        3,
                        2
                    ];
                    return [
                        4,
                        interaction.editReply('Prompt cannot be empty.')
                    ];
                case 1:
                    _state.sent();
                    return [
                        2
                    ];
                case 2:
                    return [
                        4,
                        interaction.reply({
                            content: 'Generating image...',
                            withResponse: true
                        })
                    ];
                case 3:
                    _state.sent();
                    gemini = new GoogleGenAI({
                        apiKey: process.env.GEMINI_API_KEY
                    });
                    _state.label = 4;
                case 4:
                    _state.trys.push([
                        4,
                        10,
                        ,
                        12
                    ]);
                    return [
                        4,
                        gemini.models.generateContent({
                            model: 'gemini-2.5-flash',
                            contents: prompt,
                            config: {
                                responseModalities: [
                                    Modality.IMAGE,
                                    Modality.TEXT
                                ],
                                temperature: 2,
                                maxOutputTokens: 1024
                            }
                        })
                    ];
                case 5:
                    response = _state.sent();
                    parts = ((_response_candidates = response.candidates) === null || _response_candidates === void 0 ? void 0 : (_response_candidates_ = _response_candidates[0]) === null || _response_candidates_ === void 0 ? void 0 : (_response_candidates__content = _response_candidates_.content) === null || _response_candidates__content === void 0 ? void 0 : _response_candidates__content.parts) || [];
                    imageBuffer = null;
                    caption = '';
                    _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
                    try {
                        for(_iterator = parts[Symbol.iterator](); !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            part = _step.value;
                            ;
                            if ((_part_inlineData = part.inlineData) === null || _part_inlineData === void 0 ? void 0 : _part_inlineData.data) {
                                imageBuffer = Buffer.from(part.inlineData.data, 'base64');
                            } else if (part.text) {
                                caption += part.text + '\n';
                            }
                        }
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return != null) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    if (!imageBuffer) return [
                        3,
                        7
                    ];
                    imgPath = path.join(__dirname, 'out.png');
                    fs.writeFileSync(imgPath, imageBuffer);
                    return [
                        4,
                        interaction.editReply({
                            content: caption.trim() || 'Here’s your image:',
                            files: [
                                imgPath
                            ]
                        })
                    ];
                case 6:
                    _state.sent();
                    fs.unlinkSync(imgPath);
                    return [
                        3,
                        9
                    ];
                case 7:
                    return [
                        4,
                        interaction.editReply('No image could be generated for that prompt.')
                    ];
                case 8:
                    _state.sent();
                    _state.label = 9;
                case 9:
                    return [
                        3,
                        12
                    ];
                case 10:
                    error = _state.sent();
                    console.error('Error during Gemini image generation:', error);
                    return [
                        4,
                        interaction.editReply('Sorry, I couldn’t generate that image right now.')
                    ];
                case 11:
                    _state.sent();
                    return [
                        3,
                        12
                    ];
                case 12:
                    return [
                        2
                    ];
            }
        });
    })();
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
import { SlashCommandBuilder } from 'discord.js';
export var data = new SlashCommandBuilder().setName('ping').setDescription('Check bot latency and API response time.');
export function execute(interaction) {
    return _async_to_generator(function() {
        var sent, latency, apiPing;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    return [
                        4,
                        interaction.reply({
                            content: 'Pinging...',
                            withResponse: true
                        })
                    ];
                case 1:
                    sent = _state.sent();
                    latency = sent.interaction.createdTimestamp - interaction.createdTimestamp;
                    apiPing = interaction.client.ws.ping;
                    return [
                        4,
                        interaction.editReply("\uD83C\uDFD3 Pong!\n- Response Time: **".concat(latency, "ms**\n- API Latency: **").concat(apiPing, "ms**"))
                    ];
                case 2:
                    _state.sent();
                    return [
                        2
                    ];
            }
        });
    })();
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
export var name = 'interactionCreate';
export function execute(interaction) {
    return _async_to_generator(function() {
        var command, error;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!interaction.isChatInputCommand()) {
                        return [
                            2
                        ];
                    }
                    command = interaction.client.commands.get(interaction.commandName);
                    if (!command) {
                        console.error("No command matching ".concat(interaction.commandName, " was found."));
                        return [
                            2
                        ];
                    }
                    _state.label = 1;
                case 1:
                    _state.trys.push([
                        1,
                        3,
                        ,
                        4
                    ]);
                    return [
                        4,
                        command.execute(interaction)
                    ];
                case 2:
                    _state.sent();
                    return [
                        3,
                        4
                    ];
                case 3:
                    error = _state.sent();
                    console.error('interactionCreate error: ', error);
                    return [
                        3,
                        4
                    ];
                case 4:
                    return [
                        2
                    ];
            }
        });
    })();
}

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
import systemInstructions from '../lib/systemInstructions.js';
import config from '../../config.json';
import { newMentionLog, newResponseLog, newReplyLengthErrorLog, newCreateChatErrorLog, newSendMessageErrorLog } from '../lib/logging.js';
import { validReply, botShouldReply, substituteMentionUsernames, substituteNamesWithMentions, createHistory, formatUsageMetadata } from '../lib/utils.js';
export var name = 'messageCreate';
export function execute(message, client, gemini) {
    return _async_to_generator(function() {
        var _message_author, _message_author1, _client_user, _client_user1, _message_guild, _response_candidates_, _response_candidates, errorMessage, currentTime, authorName, content, botName, systemInstruction, botReply, isDM, location, history, chat, response, error, responseText, modelVersion, usageMetadata, finishReason, finalResponse;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    if (!botShouldReply(message, client)) {
                        return [
                            2
                        ];
                    }
                    (function() {
                        return _async_to_generator(function() {
                            return _ts_generator(this, function(_state) {
                                return [
                                    2,
                                    new Promise(function(resolve) {
                                        return setTimeout(resolve, 5000);
                                    })
                                ];
                            });
                        })();
                    })();
                    errorMessage = 'Sorry, there was an error while processing your message. Please try again later.';
                    currentTime = new Date().toString();
                    authorName = ((_message_author = message.author) === null || _message_author === void 0 ? void 0 : _message_author.globalName) || ((_message_author1 = message.author) === null || _message_author1 === void 0 ? void 0 : _message_author1.username) || 'Unknown User';
                    content = substituteMentionUsernames(message.content, message.mentions.users);
                    botName = ((_client_user = client.user) === null || _client_user === void 0 ? void 0 : _client_user.globalName) || ((_client_user1 = client.user) === null || _client_user1 === void 0 ? void 0 : _client_user1.username) || config.messageCreateConfigs.responseConfigs.botCustomName;
                    systemInstruction = systemInstructions.messageCreate(botName, authorName, currentTime);
                    return [
                        4,
                        message.reply('Thinking...')
                    ];
                case 1:
                    botReply = _state.sent();
                    isDM = message.channel.isDMBased();
                    location = isDM ? 'DM' : "".concat((_message_guild = message.guild) === null || _message_guild === void 0 ? void 0 : _message_guild.name, " -> ").concat(message.channel.name);
                    newMentionLog(currentTime, authorName, content, isDM, location);
                    return [
                        4,
                        createHistory(message, client)
                    ];
                case 2:
                    history = _state.sent();
                    try {
                        chat = gemini.chats.create({
                            // model: 'gemini-2.5-flash-lite-preview-06-17',
                            // model: 'gemini-2.5-pro',
                            model: 'gemini-2.5-flash',
                            config: {
                                temperature: 0.7,
                                maxOutputTokens: 500,
                                systemInstruction: systemInstruction,
                                thinkingConfig: {
                                    thinkingBudget: 0
                                }
                            },
                            history: history
                        });
                    } catch (error) {
                        botReply.edit(errorMessage);
                        newCreateChatErrorLog(currentTime, error, history);
                        return [
                            2
                        ];
                    }
                    _state.label = 3;
                case 3:
                    _state.trys.push([
                        3,
                        5,
                        ,
                        6
                    ]);
                    return [
                        4,
                        chat.sendMessage({
                            message: content
                        })
                    ];
                case 4:
                    response = _state.sent();
                    return [
                        3,
                        6
                    ];
                case 5:
                    error = _state.sent();
                    newSendMessageErrorLog(currentTime, error, content, history);
                    botReply.edit(errorMessage);
                    return [
                        2
                    ];
                case 6:
                    responseText = (response === null || response === void 0 ? void 0 : response.text) || '(no text)';
                    modelVersion = (response === null || response === void 0 ? void 0 : response.modelVersion) || '(unknown model version)';
                    usageMetadata = formatUsageMetadata(response === null || response === void 0 ? void 0 : response.usageMetadata);
                    finishReason = (response === null || response === void 0 ? void 0 : (_response_candidates = response.candidates) === null || _response_candidates === void 0 ? void 0 : (_response_candidates_ = _response_candidates[0]) === null || _response_candidates_ === void 0 ? void 0 : _response_candidates_.finishReason) || '(unknown finish reason)';
                    newResponseLog(currentTime, responseText, modelVersion, usageMetadata, finishReason);
                    if (!validReply(response)) {
                        botReply.edit(errorMessage);
                        newReplyLengthErrorLog(currentTime, responseText.length, isDM);
                        return [
                            2
                        ];
                    }
                    finalResponse = substituteNamesWithMentions(response.text, message.mentions.users);
                    botReply.edit(finalResponse);
                    return [
                        2
                    ];
            }
        });
    })();
}

function _array_like_to_array(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];
    return arr2;
}
function _array_without_holes(arr) {
    if (Array.isArray(arr)) return _array_like_to_array(arr);
}
function _iterable_to_array(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
function _non_iterable_spread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _to_consumable_array(arr) {
    return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}
function _unsupported_iterable_to_array(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return _array_like_to_array(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(n);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _array_like_to_array(o, minLen);
}
import 'dotenv/config';
import fs from 'fs';
import path from 'path';
import { createServer } from 'node:http';
import { Client, Collection, GatewayIntentBits, Partials } from 'discord.js';
import { GoogleGenAI } from '@google/genai';
import { fileURLToPath } from 'url';
var __filename = fileURLToPath(import.meta.url);
var __dirname = path.dirname(__filename);
var server = createServer();
server.listen(3000, '0.0.0.0');
var client = new Client({
    intents: [
        GatewayIntentBits.Guilds,
        GatewayIntentBits.GuildMessages,
        GatewayIntentBits.MessageContent,
        GatewayIntentBits.DirectMessages
    ],
    partials: [
        Partials.Channel
    ]
});
var gemini = new GoogleGenAI({
    apiKey: process.env.GEMINI_API_KEY
});
client.commands = new Collection();
var commandsPath = path.join(__dirname, 'commands');
var commandFiles = fs.readdirSync(commandsPath).filter(function(file) {
    return file.endsWith('.js');
});
var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
try {
    for(var _iterator = commandFiles[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
        var file = _step.value;
        var filePath = path.join(commandsPath, file);
        var command = await import(filePath);
        if ('data' in command && 'execute' in command) {
            client.commands.set(command.data.name, command);
        } else {
            console.log("[ WARNING ] > ".concat(file, " expected 'data' & 'execute'"));
        }
    }
} catch (err) {
    _didIteratorError = true;
    _iteratorError = err;
} finally{
    try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
        }
    } finally{
        if (_didIteratorError) {
            throw _iteratorError;
        }
    }
}
var eventPath = path.join(__dirname, 'events');
var eventFiles = fs.readdirSync(eventPath).filter(function(file) {
    return file.endsWith('.js');
});
var _iteratorNormalCompletion1 = true, _didIteratorError1 = false, _iteratorError1 = undefined;
try {
    var _loop = async function() {
        var file = _step1.value;
        var filePath = path.join(eventPath, file);
        var event = await import(filePath);
        if (event.once) {
            var _event;
            client.once(event.name, function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                return (_event = event).execute.apply(_event, _to_consumable_array(args).concat([
                    client,
                    gemini
                ]));
            });
        } else {
            client.on(event.name, function() {
                for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
                    args[_key] = arguments[_key];
                }
                var _event;
                (_event = event).execute.apply(_event, _to_consumable_array(args).concat([
                    client,
                    gemini
                ]));
            });
        }
    };
    for(var _iterator1 = eventFiles[Symbol.iterator](), _step1; !(_iteratorNormalCompletion1 = (_step1 = _iterator1.next()).done); _iteratorNormalCompletion1 = true)await _loop();
} catch (err) {
    _didIteratorError1 = true;
    _iteratorError1 = err;
} finally{
    try {
        if (!_iteratorNormalCompletion1 && _iterator1.return != null) {
            _iterator1.return();
        }
    } finally{
        if (_didIteratorError1) {
            throw _iteratorError1;
        }
    }
}
client.login(process.env.DISCORD_TOKEN);
client.on('ready', function() {
    console.log('Gemini is ready 7u7');
});
client.on('error', function(error) {
    console.error('Discord client error:', error);
});

export function newMentionLog(currentTime, authorName, content, isDM, location) {
    console.log("[ Log: mention ] > At: ".concat(currentTime, "\n"), "   Interaction: ".concat(isDM ? 'DM' : 'mention', "\n"), "   Author: ".concat(authorName, "\n"), "   Location: ".concat(location, "\n"), '   content: "'.concat(content, '"\n'));
}
export function newResponseLog(currentTime, responseText, modelVersion, usageMetadata, finishReason) {
    console.log("[ Log: response ] > At: ".concat(currentTime, "\n") + "   Text: ".concat(responseText, "\n") + "   Model Version: ".concat(modelVersion, "\n") + "   Usage Metadata:\n" + "".concat(usageMetadata, "\n") + "   Finish Reason: ".concat(finishReason, "\n"));
}
export function newReplyLengthErrorLog(currentTime, replyLength, isDM) {
    console.log("[ Log: reply length error ] > At: ".concat(currentTime, "\n") + "   Reply Length: ".concat(replyLength, " characters\n") + "   Is DM: ".concat(isDM, "\n"), "   Note: Reply length exceeds the maximum allowed length.\n");
}
export function newCreateChatErrorLog(currentTime, error, history) {
    console.log("[ Log: create chat error ] > At: ".concat(currentTime, "\n") + "   History Length: ".concat(history.length, "\n") + "   History: ".concat(JSON.stringify(history, null, 2), "\n"));
    console.error(error);
}
export function newSendMessageErrorLog(time, error, content, history) {
    console.log("[ Log: send message error ] > At: ".concat(time, "\n") + '   Content: "'.concat(content, '"\n') + "   History Length: ".concat(history.length, "\n") + "   History: ".concat(JSON.stringify(history, null, 2), "\n"));
    console.error(error);
}

var systemInstructions = {
    messageCreate: function(botName, authorName, currentTime) {
        return [
            'YOUR ROLE: You are a discord chatbot',
            "You are called ".concat(botName),
            "User to respond: ".concat(authorName),
            'Your responses should be as neutral and informative as possible, but if you detect a joking tone in a message, you can answer with a funny tone',
            'LIMITATION: Your messages have to be less than 2000 chars long because of the discord limits.',
            'You should use markdown to format your messages any time you can, but DO NOT use markdown tables.',
            'You should use emojis to make your messages more friendly, but do not overuse them.',
            'If the message is empty, you should respond with a frienly greeting.',
            "EXTRA INFORMATION: Current time is: ".concat(currentTime)
        ];
    }
};
export default systemInstructions;

export { };

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _async_to_generator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
function _ts_generator(thisArg, body) {
    var f, y, t, _ = {
        label: 0,
        sent: function() {
            if (t[0] & 1) throw t[1];
            return t[1];
        },
        trys: [],
        ops: []
    }, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
    }), g;
    function verb(n) {
        return function(v) {
            return step([
                n,
                v
            ]);
        };
    }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while(g && (g = 0, op[0] && (_ = 0)), _)try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [
                op[0] & 2,
                t.value
            ];
            switch(op[0]){
                case 0:
                case 1:
                    t = op;
                    break;
                case 4:
                    _.label++;
                    return {
                        value: op[1],
                        done: false
                    };
                case 5:
                    _.label++;
                    y = op[1];
                    op = [
                        0
                    ];
                    continue;
                case 7:
                    op = _.ops.pop();
                    _.trys.pop();
                    continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                        _ = 0;
                        continue;
                    }
                    if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                        _.label = op[1];
                        break;
                    }
                    if (op[0] === 6 && _.label < t[1]) {
                        _.label = t[1];
                        t = op;
                        break;
                    }
                    if (t && _.label < t[2]) {
                        _.label = t[2];
                        _.ops.push(op);
                        break;
                    }
                    if (t[2]) _.ops.pop();
                    _.trys.pop();
                    continue;
            }
            op = body.call(thisArg, _);
        } catch (e) {
            op = [
                6,
                e
            ];
            y = 0;
        } finally{
            f = t = 0;
        }
        if (op[0] & 5) throw op[1];
        return {
            value: op[0] ? op[1] : void 0,
            done: true
        };
    }
}
import config from '../../config.json';
export function substituteMentionUsernames(content, mentions) {
    if (!content || content.length === 0) {
        return '';
    }
    if (!mentions || mentions.size === 0) {
        return content;
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = mentions.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var user = _step.value;
            var regex = new RegExp("<@!?".concat(user.id, ">"), 'g');
            content = content.replace(regex, user.username);
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return content;
}
export function substituteNamesWithMentions(content, mentions) {
    if (!content || content.length === 0) {
        return '';
    }
    if (!mentions || mentions.size === 0) {
        return content;
    }
    var _iteratorNormalCompletion = true, _didIteratorError = false, _iteratorError = undefined;
    try {
        for(var _iterator = mentions.values()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
            var user = _step.value;
            var regex = new RegExp("\\b".concat(user.username, "\\b"), 'gi');
            content = content.replace(regex, "<@".concat(user.id, ">"));
        }
    } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
    } finally{
        try {
            if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
            }
        } finally{
            if (_didIteratorError) {
                throw _iteratorError;
            }
        }
    }
    return content;
}
export function botShouldReply(message, client) {
    var _client_user;
    if (!message.channel.isDMBased() && !message.mentions.has(client.user) && !message.author.bot) {
        return false;
    }
    if (message.mentions.everyone) {
        return false;
    }
    if (message.author.tag === ((_client_user = client.user) === null || _client_user === void 0 ? void 0 : _client_user.tag)) {
        return false;
    }
    if (!message.content) {
        return false;
    }
    return true;
}
export function validReply(response) {
    if (!response) {
        return false;
    }
    try {
        var text = response.text;
        if (!text || text.trim().length === 0) {
            return false;
        }
        if (text.trim().length > 2000) {
            return false;
        }
        return true;
    } catch (e) {
        return false;
    }
}
export function createHistory(message, client) {
    return _async_to_generator(function() {
        var maxHistoryLengthConfig, maxHistoryLength, history, cursor, _client_user, parent, role;
        return _ts_generator(this, function(_state) {
            switch(_state.label){
                case 0:
                    maxHistoryLengthConfig = config.messageCreateConfigs.generationParameters.maxHistoryLength || 10;
                    maxHistoryLength = maxHistoryLengthConfig > 0 ? maxHistoryLengthConfig : Number.MAX_SAFE_INTEGER;
                    history = [];
                    cursor = message;
                    _state.label = 1;
                case 1:
                    if (!(cursor.reference && cursor.reference.messageId)) return [
                        3,
                        3
                    ];
                    return [
                        4,
                        message.channel.messages.fetch(cursor.reference.messageId)
                    ];
                case 2:
                    parent = _state.sent();
                    role = parent.author.id === ((_client_user = client.user) === null || _client_user === void 0 ? void 0 : _client_user.id) ? 'model' : 'user';
                    history.unshift({
                        role: role,
                        parts: [
                            {
                                text: parent.content
                            }
                        ]
                    });
                    if (history.length >= maxHistoryLength && role === 'user') {
                        return [
                            3,
                            3
                        ];
                    }
                    cursor = parent;
                    return [
                        3,
                        1
                    ];
                case 3:
                    return [
                        2,
                        history
                    ];
            }
        });
    })();
}
export function formatUsageMetadata(usageMetadata) {
    if (!usageMetadata) {
        return '(no usage metadata)';
    }
    var responseFormated = JSON.stringify(usageMetadata, null, 2).split('\n').map(function(line) {
        return "   ".concat(line);
    }).join('\n');
    return responseFormated;
}




